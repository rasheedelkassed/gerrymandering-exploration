<canvas id="canvas" oncontextmenu="return false;"></canvas>
<style type="text/css">
    canvas{
        position: absolute;
        overflow: hidden;
    }
    body{
        margin: 0;
        overflow: hidden;
    }
</style>

<script>

// Get the canvas to draw on
let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");

// Set canvas height to the size of the entire window
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let xCenter = canvas.width / 2;
let yCenter = canvas.height / 2;

// Intialize mouse tracking
let mouse = {
    x: undefined,
    y: undefined,
    down: false
}

// Add event listeners to track what the mouse is doing on the canvas
canvas.addEventListener('mousemove', 
function(event) {
    mouse.x = event.x;
    mouse.y = event.y;
})

canvas.addEventListener('mousedown', 
function(event) {
    mouse.down = true;
})

canvas.addEventListener('mouseup', 
function(event) {
    mouse.down = false;
})

canvas.addEventListener('mouseleave', 
function(event) {
    mouse.down = false;
})

// Create a referencable rect object on a canvas
class Neighborhood{
    constructor(xPos, yPos, width, height, spriteSource=""){
        this.xPos = xPos;
        this.yPos = yPos;    
        this.width = width;
        this.height = height;
        this.filled = false;
        this.selected = false;
        this.color = null;
        this.sprite = new Image()
        this.sprite.src = spriteSource;
    }

    draw(){
        if(this.filled){
            context.fillRect(this.xPos, this.yPos, this.width, this.height);
        }
        else if(this.selected){
            context.lineWidth = 3;
        }
        context.strokeRect(this.xPos, this.yPos, this.width, this.height);
        context.drawImage(this.sprite, this.xPos, this.yPos, this.width, this.height)
        context.lineWidth = 1;
        
        
    }
}

// Create the "game" board
class GameBoard{
    constructor(width, height, cellWidth = 30, cellHeight = 30, maxDistrictSize = 4){
        this.width = width;                     //The number of neighborhoods horizontally
        this.height = height;                   //The number of neighborhoods vertically
        this.cellWidth = cellWidth;             //The size of a neighborhood in pixels horizontally
        this.cellHeight = cellHeight;           //The size of a neighborhood in pixels vertically
        this.cityGrid = [];                     //The grid of neighborhoods used to reference specific neighborhoods
        this.shouldFill = null;
        this.maxDistrictSize = maxDistrictSize; //The number of squares that are changed in a single stroke
        this.currentDistrictSize = 0;
        this.districts = [];
        this.maxDistrictCount = 4;
        this.currentDistrict = [];

        this.createCityGrid();
    }

    createCityGrid(){
        let currentXCell = 0;
        let currentYCell = 0;
        while(currentYCell < this.height){
            let row = []
            while(currentXCell < this.width){
                row.push(new Neighborhood(
                    Math.floor(xCenter - this.width * (this.cellWidth/2)) + currentXCell * this.cellWidth + 0.5,
                    Math.floor(yCenter - this.height * (this.cellHeight/2)) + currentYCell * this.cellHeight + 0.5,
                    this.cellWidth,
                    this.cellHeight))
                currentXCell += 1;
            }
            this.cityGrid.push(row);
            currentXCell = 0;
            currentYCell += 1;
        }
    }

    /// TODO: Make this not an abomination to humanity 
    /// TODO: Figure out way to change grid[y][x] to be grid[x][y] for better read
    // Return the current neighborhood being pointed at by the mouse
    getNeighborhoodByMousePos(){
        let cellCoords = this.getCellsFromPixels(mouse.x, mouse.y);

        return this.getNeighborhood(cellCoords.x, cellCoords.y);
    }

    // Get the neighborhood based on the city grid's cell coordinates
    getNeighborhood(xCell, yCell){
        if(this.cityGrid[yCell] != null && this.cityGrid[yCell][xCell] != null){
            return this.cityGrid[yCell][xCell];
        }else{
            return null;
        }
        
    }

    // Convert canvas coordinates to cell coordinates
    getCellsFromPixels(x, y){
        let xCell = Math.floor((x - Math.floor(xCenter - this.width * (this.cellWidth/2)) - 0.5) / this.cellWidth);
        let yCell = Math.floor((y - Math.floor(yCenter - this.height * (this.cellHeight/2)) - 0.5) / this.cellHeight);
        return {x: xCell, y: yCell};
    }

    // TODO: Bring those if statements down to more acceptable levels
    drawDistrict(){
        if(mouse.down){
            if(this.currentDistrictSize < this.maxDistrictSize){
                let neighborhood = this.getNeighborhoodByMousePos();
                if(neighborhood != null){
                    if(!neighborhood.selected){
                        neighborhood.selected = true;
                        this.currentDistrictSize += 1; 
                        this.currentDistrict.push(neighborhood);
                    }else if(this.currentDistrictSize == 0){
                        console.log(this.findNeighborhoodsCurrentDistrictIndex(neighborhood));
                        this.deSelectDistrict(this.districts[this.findNeighborhoodsCurrentDistrictIndex(neighborhood)]);
                    }
                }
            }
        }else{
            this.currentDistrictSize = 0;
            if(this.districts.length <= this.maxDistrictCount 
                                    && this.currentDistrict.length > 0
                                    && this.isDistrictConnected(this.currentDistrict)){
                this.districts.push(this.currentDistrict);
            }else{
                this.deSelectDistrict(this.currentDistrict);
            }
            this.currentDistrict = [];
        }
    }

    deSelectDistrict(district){
        district.forEach(neighborhood => neighborhood.selected = false);
    }

    findNeighborhoodsCurrentDistrictIndex(neighborhood){
        if(!neighborhood.selected){
            return null
        }
        let foundDistrictIndex = null;
        for(let i = 0; i < this.districts.length; i++){
            if(this.districts[i].includes(neighborhood)){
                foundDistrictIndex = i;
                break;
            }
        }
        return foundDistrictIndex;
    }

    // Essentially a bredth-first search
    isDistrictConnected(district){
        let foundConnectedPairs = 0;
        for(let i = 0; i < district.length; i++){
            for(let j = i; j < district.length; j++){
                if(this.areNeighborhoodsAdjacent(district[i], district[j])){
                    foundConnectedPairs += 1;
                }
            }
        }
        if(foundConnectedPairs >= district.length - 1){
            return true;
        }else{
            return false;
        }
        
        
    }

    areNeighborhoodsAdjacent(firstNeighborhood, secondNeighborhood){
        let firstNeighborhoodCells = this.getCellsFromPixels(firstNeighborhood.xPos, firstNeighborhood.yPos);
        let secondNeighborhoodCells = this.getCellsFromPixels(secondNeighborhood.xPos, secondNeighborhood.yPos);

        let diff = Math.abs(firstNeighborhoodCells.x - secondNeighborhoodCells.x) + Math.abs(firstNeighborhoodCells.y - secondNeighborhoodCells.y)
        if(diff == 1){
            return true;
        }else{
            return false;
        }
    }

    draw(){
        this.cityGrid.forEach(element => {
            element.forEach(square => {
                square.draw();
            });
        });
    }

    update(){
        this.drawDistrict();
        this.draw();
    }
}

let squareSize = 100;
let gameBoard = new GameBoard(Math.floor(canvas.width / squareSize), Math.floor(canvas.height / squareSize), squareSize, squareSize);


animate = () => {
    context.clearRect(0, 0, canvas.width, canvas.height);
    gameBoard.update();


    requestAnimationFrame(animate);
}

requestAnimationFrame(animate);

</script>